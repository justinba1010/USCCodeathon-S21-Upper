/* Copyright 2021
** Justin Baum
** MIT License
** AlgoExpert Solutions
*/



// Start of BODY
/**
 * TestStruct members::
 *  testcase_id                   [size_t] ID of the test-case
 *  testcase_input_path           [string] File path to test-case input
 *  testcase_output_path          [string] File path to test-case output generated by the problem solver
 *  testcase_expected_output_path [string] File path to test-case expected output to be matched with
 *  testcase_error_path           [string] File path to test-case STDERR
 *  metadata_file_paths           [vector<string>] File paths to Question metadata (Extra files usually used for defining traning sets)
 *  submission_code_path          [string] File path to submission source code
 *  submission_language           [string] Language token of submission
 *  testcase_result               [bool] Set to true if test-case output matches test-case expected output. Matching is done line by line
 *  testcase_signal               [size_t] Exit code of the test-case process
 *  testcase_time                 [float] Time taken by the test-case process in seconds
 *  testcase_memory               [size_t] Peak memory of the test-case process determined in bytes
 *  data                          [string] <Future use>
 *
 *
 *  ResultStruct::
 *    result      [bool]  Assign test-case result. true determines success. false determines failure
 *    score       [float] Assign test-case score. Normalized between 0 to 1
 *    message     [string] Assign test-case message. This message is visible to the problem solver
**/


void run_custom_checker(const TestStruct t_obj,
                        ResultStruct &r_obj) {
    //Don't print anything to STDOUT in this function
    //Enter your custom checker scoring logic here
    ifstream expected, output, input;
    map<string, int> indexOfMeme;
    vector<int> jumps;
    vector<string> memes;
    int n;
    input.open(t_obj.testcase_input_path);
    input >> n;
    for (int i = 0; i < n; ++i) {
        int x;
        input >> x;
        jumps.push_back(x);
    }
    for (int i = 0; i < n; ++i) {
        string m;
        input >> m;
        memes.push_back(m);
        indexOfMeme[m] = i;
    }
    
    expected.open(t_obj.testcase_expected_output_path);
    int answer = 0;
    string memethrow;
    while (expected >> memethrow) {
        ++answer;
    }
    
    output.open(t_obj.testcase_output_path);
    int index = 0;
    int count = 0;
    r_obj.message = "";
    string last = "";
    while (output >> memethrow) {
        ++count;
        auto x = indexOfMeme.find(memethrow);
        r_obj.message += memethrow;
        if (x == indexOfMeme.end()) {
            r_obj.result = false;
            r_obj.score = 0.0;
            r_obj.message += "You used an illegal meme.";
            return;
        }
        int jumpss = jumps[x->second];
        if (x->second > index + jumpss) {
            r_obj.result = false;
            r_obj.score = 0.0;
            r_obj.message = "You made an illegal jump.";
            return;
        }
        index = x->second + jumpss;
        last = memethrow;
    }
    if (last != memes[n-1]) {
        r_obj.result = false;
        r_obj.score = 0.0;
        r_obj.message = "You didn't jump land on the last meme.";
        return;
    }
    if (count > answer) {
        r_obj.result = false;
        r_obj.score = 0.0;
        r_obj.message = "You had too many jumps.";
        return;
    }
    if (index < n) {
        r_obj.result = false;
        r_obj.score = 0.0;
        r_obj.message = "Didn't make it to the end";
        return;
    }
    if (count < answer) {
        r_obj.result = false;
        r_obj.score = 0.0;
        r_obj.message = "IF YOU SEE THIS LET SOMEONE KNOW";
        return;
    }
    
    
    
    r_obj.result = true;
    r_obj.score = 1.0f;
    r_obj.message = "Success";
}
// End of BODY
        
